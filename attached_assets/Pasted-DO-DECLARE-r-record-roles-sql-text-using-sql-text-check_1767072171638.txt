DO $$
DECLARE
  r record;
  roles_sql text;
  using_sql text;
  check_sql text;
  permissive_clause text;
  with_check_clause text;
  cmd_sql text;
  create_sql text;
BEGIN
  FOR r IN
    SELECT
      schemaname,
      tablename,
      policyname,
      permissive,
      roles,
      cmd,
      -- if qual is a pg_node_tree, convert it to readable SQL with pg_get_expr.
      -- otherwise assume it's already text and use it directly.
      COALESCE(
        CASE
          WHEN pg_typeof(qual)::text = 'pg_node_tree' THEN
            pg_get_expr(qual, format('%I.%I', schemaname, tablename)::regclass)
          ELSE
            qual
        END,
        'TRUE'
      ) AS using_clause,
      COALESCE(
        CASE
          WHEN pg_typeof(with_check)::text = 'pg_node_tree' THEN
            pg_get_expr(with_check, format('%I.%I', schemaname, tablename)::regclass)
          ELSE
            with_check
        END,
        'TRUE'
      ) AS check_clause
    FROM pg_policies
    WHERE schemaname = 'public'
      AND tablename IN ('user_profiles', 'invitations', 'scoreboard_entries', 'scoreboards')
  LOOP
    -- roles
    IF r.roles IS NULL OR cardinality(r.roles) = 0 THEN
      roles_sql := 'PUBLIC';
    ELSE
      roles_sql := array_to_string(
        ARRAY(SELECT quote_ident(role_name) FROM unnest(r.roles) AS role_name),
        ', '
      );
    END IF;

    -- replace auth function calls with a wrapped form to be safe in generated SQL
    using_sql := replace(replace(COALESCE(r.using_clause, ''), 'auth.uid()', '(SELECT auth.uid())'), 'auth.jwt()', '(SELECT auth.jwt())');
    check_sql := replace(replace(COALESCE(r.check_clause, ''), 'auth.uid()', '(SELECT auth.uid())'), 'auth.jwt()', '(SELECT auth.jwt())');

    IF trim(using_sql) = '' THEN
      using_sql := 'TRUE';
    END IF;

    IF trim(check_sql) = '' THEN
      check_sql := 'TRUE';
    END IF;

    cmd_sql := upper(r.cmd);

    -- permissive is boolean in pg_policies
    permissive_clause := CASE WHEN r.permissive THEN '' ELSE ' AS RESTRICTIVE' END;

    -- drop existing policy
    EXECUTE format('DROP POLICY IF EXISTS %I ON %I.%I', r.policyname, r.schemaname, r.tablename);

    -- build CREATE POLICY SQL
    IF cmd_sql = 'INSERT' THEN
      -- INSERT policies only use WITH CHECK
      create_sql := format(
        'CREATE POLICY %I ON %I.%I%s FOR %s TO %s WITH CHECK (%s)',
        r.policyname,
        r.schemaname,
        r.tablename,
        permissive_clause,
        cmd_sql,
        roles_sql,
        check_sql
      );
    ELSE
      -- SELECT, UPDATE, DELETE, ALL use USING (and optionally WITH CHECK)
      with_check_clause := CASE
        WHEN cmd_sql IN ('ALL', 'UPDATE') AND check_sql <> 'TRUE'
          THEN format(' WITH CHECK (%s)', check_sql)
        ELSE ''
      END;

      create_sql := format(
        'CREATE POLICY %I ON %I.%I%s FOR %s TO %s USING (%s)%s',
        r.policyname,
        r.schemaname,
        r.tablename,
        permissive_clause,
        cmd_sql,
        roles_sql,
        using_sql,
        with_check_clause
      );
    END IF;

    -- execute the creation
    EXECUTE create_sql;
  END LOOP;
END;
$$;