Summary of the issue
Title: Auth RLS Initialization Plan — public.invitations
Problem: The RLS policy authenticated_users_create_invitations on table public.invitations calls auth.<function>() (or current_setting()) directly in the policy expression. That causes the function to be re-evaluated for every row the policy checks, which can cause significant performance overhead at scale.
Why it matters: Direct calls like auth.uid() or current_setting('jwt.claims.xyz') inside USING or WITH CHECK expressions are evaluated per-row by Postgres when RLS runs. For large scans/updates/inserts, this increases CPU work and slows queries. Supabase recommends wrapping those calls in a scalar subquery so the value is computed once per statement and the planner can better optimize access.
Recommended fixes (concise)
Replace direct calls with a scalar subquery form:

Instead of:
auth.uid()
auth.jwt()
current_setting('...')
Use:
(SELECT auth.uid())
(SELECT auth.jwt()) — or extract a claim: (SELECT auth.jwt() ->> 'tenant_id')
(SELECT current_setting('jwt.claims.xyz', true)) — or wrap current_setting in SELECT
Apply this change to every place inside the RLS policy where these functions appear (both in USING and WITH CHECK clauses).

Example transformation

If the policy currently looks like: CREATE POLICY authenticated_users_create_invitations ON public.invitations FOR INSERT TO authenticated WITH CHECK (inviter_id = auth.uid());
Change to: CREATE POLICY authenticated_users_create_invitations ON public.invitations FOR INSERT TO authenticated WITH CHECK (inviter_id = (SELECT auth.uid()));
For JWT claim checks: ... tenant_id = (auth.jwt() ->> 'tenant_id')::uuid ... becomes: ... tenant_id = ((SELECT auth.jwt()) ->> 'tenant_id')::uuid ...
Add indexes on columns referenced by the policy (e.g., inviter_id, tenant_id) to ensure efficient row filtering.

Test after change:

Run representative SELECT/INSERT/UPDATE workloads as an authenticated user and compare latency/CPU.
Confirm policy behavior is unchanged (same rows allowed/blocked).
Why this fix works (brief)
(SELECT auth.uid()) is treated as a scalar subquery that Postgres evaluates once per statement instead of once per row. This reduces repeated function calls and helps the planner produce more efficient execution plans.
Suggested SQL snippets
Update policy (non-destructive): drop and recreate policy with the SELECT-wrapped calls. Example:
SQL Query



DROP POLICY IF EXISTS authenticated_users_create_invitations ON public.invitations;

CREATE POLICY authenticated_users_create_invitations
  ON public.invitations
  FOR INSERT TO authenticated
  WITH CHECK (
    inviter_id = (SELECT auth.uid())
  );

For claims:
SQL Query



-- example using tenant_id from JWT claims
DROP POLICY IF EXISTS some_policy ON public.invitations;

CREATE POLICY some_policy
  ON public.invitations
  FOR SELECT TO authenticated
  USING (
    tenant_id = ((SELECT auth.jwt()) ->> 'tenant_id')::uuid
  );

(Be careful: replace policy names/clauses with the actual logic of your existing policy.)

Validation steps (1–2 lines)
After applying the change, run a few representative queries and confirm policy semantics are identical and query latency/CPU improves. If you see unexpected behavior, double-check that you wrapped the exact auth/current_setting calls and preserved any casting or claim extraction.
Additional notes
This is a safe, non-destructive change to policy logic (you recreate equivalent policy). Still, test in staging first if possible.
Consider auditing other tables for the same anti-pattern and applying the same pattern project-wide for consistent performance.