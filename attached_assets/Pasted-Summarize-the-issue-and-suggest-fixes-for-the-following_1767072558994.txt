Summarize the issue and suggest fixes for the following lint item: Title: Multiple Permissive Policies Entity: public.invitations Schema: public Issue Details: Table public.invitations has multiple permissive policies for role authenticated for action SELECT. Policies include {anyone_check_invitation_validity,users_view_own_invitations} Description: Detects if multiple permissive row level security policies are present on a table for the same role and action (e.g. insert). Multiple permissive policies are suboptimal for performance as each policy must be executed for every relevant query.




Reasoned

Reasoned
Issue summary
Table: public.invitations
Problem: There are two permissive RLS policies for the same role and operation:
Role: authenticated
Action: SELECT
Policies: anyone_check_invitation_validity, users_view_own_invitations
Why this matters: PostgreSQL will evaluate every permissive policy for the matching role on each query. Having multiple permissive policies for the same role+action can degrade performance and make intent unclear — especially when one or both policies contain non-trivial logic (joins, subqueries, functions).
Risks / impact
Performance: Every SELECT by an authenticated user will run both policy expressions, increasing query cost and latency.
Maintainability: It's harder to reason about allowed rows when access is defined in multiple places. Bugs or gaps can arise if policies overlap or contradict.
Unexpected behavior: Combining permissive policies uses OR semantics: if any policy returns true the row is visible. That may be broader than intended.
Recommended fixes (ordered, pick what fits your design)
Consolidate policies into a single permissive SELECT policy

Combine the intent of both into one policy expression using explicit logic (prefer explicit boolean expressions rather than implicit joins where possible). Example pattern:
If you need to allow either “invitation is valid to anyone” OR “user is owner”, combine them: (invitation_valid_condition) OR (owner_id = (SELECT auth.uid()))
Benefits: only one expression executed per row; clearer single source of truth.
Convert one policy to a restrictive policy where appropriate

If one policy should grant broad access and the other should further restrict a subset of rows, convert the narrower rule into a policy that applies FOR UPDATE/INSERT or use WITH CHECK for writes rather than another permissive SELECT.
Alternatively, make one policy conditional on a specific role (e.g., TO authenticated WHERE (auth.jwt() ->> 'role') = 'manager') so only the intended users trigger it.
Use role-specific TO clauses

Instead of both targeting authenticated, scope one to a more specific role or JWT claim. Example: TO authenticated vs TO authenticated WHERE (auth.jwt() ->> 'is_admin') = 'true'.
This prevents both policies from running for the same user when only one should apply.
Move complex checks into a SECURITY DEFINER helper function and index referenced columns

If policy logic is complex (joins, lookups), implement a compact helper function (SECURITY DEFINER, stable) that returns boolean and call it from the policy. Example: USING (invitation_visible_to_user(NEW.id))
Revoke execute on that function from public/anon if needed.
Ensure columns used in the function/policy are indexed (e.g., owner_id, status, token) to keep performance good.
Test and measure

After changes, test typical SELECT queries as an authenticated user and measure explain/analyze to confirm reduced cost.
Verify behavior with multiple user roles to ensure no access regressions.
Example consolidation (illustrative SQL)
(Only an example — adapt column names and logic to your schema.)

-- Disable RLS while editing is optional, be careful in production
-- ALTER TABLE public.invitations DISABLE ROW LEVEL SECURITY;

-- Drop the extra permissive policy
DROP POLICY IF EXISTS anyone_check_invitation_validity ON public.invitations;

-- Create a single consolidated SELECT policy for authenticated users
CREATE POLICY authenticated_select_invitations ON public.invitations
  FOR SELECT
  TO authenticated
  USING (
    -- allow if invitation is publicly valid OR owned by the current user
    (status = 'valid' AND expires_at > now()) OR
    (owner_id = (SELECT auth.uid()))
  );
If you prefer keeping both policies, at minimum ensure they target different roles/claims so a single user won't trigger both.

Next steps I can do for you
Inspect the actual policy definitions for anyone_check_invitation_validity and users_view_own_invitations and propose a merged policy (I can fetch them if you want).
Generate concrete SQL to drop/replace policies and add helper functions, and run EXPLAIN before/after to validate improvement (I will ask for confirmation before executing any destructive SQL).